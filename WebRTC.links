open import Mvu;
open import MvuHTML;
open import MvuAttrs;
open import MvuEvents;
open import MvuSubscriptions;
import MvuCommands;


module WebRTC {
  alien javascript "/js/webRTC_functions.js" {
    setupRTCConnection : (wild) ~%~> ();
    createOfferSDP : (wild) ~%~> ();
    getOfferSDP : (wild) ~%~> (String);
    isLocalSDP : (wild) ~%~> (Bool);
    createAnswerSDP : (wild) ~%~> ();
    receiveOfferSDP : (wild, String) ~%~> ();
    isRemoteSDP : (wild) ~%~> (Bool);
    getLocalVideo : () ~%~> ();
    isLocalVideo : () ~%~> (Bool);
    getIsNewIceCandidate : (wild) ~%~> (String);
    getNewIceCandidates : (wild) ~%~> (String);
    addNewIceCandidates : (wild, String) ~%~> ();
    closeRTCConnection : (wild) ~%~> ();
  }
}

var startxind = 10;
var startyind = 10;

var sqwidth = 50;
var sqheight = 50;
var rows = 1400 / sqheight;
var columns = 1400 / sqwidth;

var lounge = (name="Lounge", xmin=1, xmax=9, ymin=1, ymax=11, members=[]);
var kitchen = (name="Kitchen", xmin=1, xmax=7, ymin=18, ymax=27, members=[]);
var study = (name="Study", xmin=12, xmax=23, ymin=20, ymax=27, members=[]);
var ballroom = (name="Ballroom", xmin=14, xmax=26, ymin=1, ymax=15, members=[]);
var lobby = (name="Lobby", xmin=10, xmax=11, ymin=16, ymax=17, members=[]);

var loungemembers = (name="Lounge", members=[]);
var kitchenmembers = (name="Kitchen", members=[]);
var studymembers = (name="Study", members=[]);
var ballroommembers = (name="Ballroom", members=[]);
var lobbymembers = (name="Lobby", members=[]);


fun broadcastPid(pid, id, currentPids, newroom, oldroom) server {
  switch (currentPids) {
    case [] -> ()
    case p::ps ->
      var proc = first(p);
      proc ! UpdateRooms(id, oldroom, newroom);
      if (oldroom == "None"){
        proc ! RequestPosition(pid)
      }
      else {

      };
      if (second(p) == id){
        broadcastPid(pid, id, ps, newroom, oldroom)
      }
      else{
        if (third(p) == newroom){
          proc ! OpenConnection(pid);
          proc ! StartCall(pid);
          broadcastPid(pid, id, ps, newroom, oldroom)
        }
        else{
          if (third(p) == oldroom){
            proc ! CloseConnection(pid);
            pid ! CloseConnection(proc);
            broadcastPid(pid, id, ps, newroom, oldroom)
          }else{
            broadcastPid(pid, id, ps, newroom, oldroom)
          }
        }
      }
      
  }
}

fun broadcastCharacterMovement(pids, pos) server {
  switch(pids){
    case [] -> 
      ()
    case p::ps ->
      var proc = first(p);
      if(second(p) == pos.pid){
        proc ! Move(pos);
        broadcastCharacterMovement(ps, pos)
      }else{
        proc ! OtherMoved(pos);
        broadcastCharacterMovement(ps, pos)
      }  
  }
}

fun createRow(height, width, row, columns){
  for (c <- columns){
    if(row >= lounge.xmin && row <= lounge.xmax && c >= lounge.ymin && c <= lounge.ymax){
      [(tpos=height*.intToFloat(row), lpos=width*.intToFloat(c), room="Lounge")]
    }
    else if(row >= kitchen.xmin && row <= kitchen.xmax && c >= kitchen.ymin && c <= kitchen.ymax){
      [(tpos=height*.intToFloat(row), lpos=width*.intToFloat(c), room="Kitchen")]
    }
    else if(row >= study.xmin && row <= study.xmax && c >= study.ymin && c <= study.ymax){
      [(tpos=height*.intToFloat(row), lpos=width*.intToFloat(c), room="Study")]
    }
    else if(row >= ballroom.xmin && row <= ballroom.xmax && c >= ballroom.ymin && c <= ballroom.ymax){
      [(tpos=height*.intToFloat(row), lpos=width*.intToFloat(c), room="Ballroom")]
    }
    else{
      [(tpos=height*.intToFloat(row), lpos=width*.intToFloat(c), room="Lobby")]
    }
  }
}



fun createGrid(height, width, rows, columns){
  for (r <- rows){
    [createRow(height, width, r, columns)]
  }
}

fun getNewRoomPos(rooms, grid, pid, currxind, curryind, newroom){
  switch(rooms){
    case [] -> 
      var newxind = currxind;
      var newyind = curryind;
      var square = selectElem(selectElem(grid, newxind), newyind);
      var newroom = square.room;
      var newxpos = square.tpos;
      var newypos = square.lpos;
      (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
    case p::ps ->
      if (p.name == newroom){
        var newxind = p.xmin;
        var newyind = p.ymin;
        var square = selectElem(selectElem(grid, newxind), newyind);
        var newroom = square.room;
        var newxpos = square.tpos;
        var newypos = square.lpos;
        (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
      } else{
        getNewRoomPos(ps, grid, pid, currxind, curryind, newroom)
      }
  }
}

fun getGridPos(grid, pid, currxind, curryind,code){
  switch(code){
        case "Init" ->
          var newxind = currxind;
          var newyind = curryind;
          var square = selectElem(selectElem(grid, newxind), newyind);
          var newroom = square.room;
          var newxpos = square.tpos;
          var newypos = square.lpos;
          (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
        case "ArrowDown" -> 
          if (currxind == rows-2){
            var newxind = currxind;
            var newyind = curryind;
            var square = selectElem(selectElem(grid, newxind), newyind);
            var newroom = square.room;
            var newxpos = square.tpos;
            var newypos = square.lpos;
            (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
          }
          else {
            var newxind = currxind+1;
            var newyind = curryind;
            var square = selectElem(selectElem(grid, newxind), newyind);
            var newroom = square.room;
            var newxpos = square.tpos;
            var newypos = square.lpos;
            (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
          }
          
        case "ArrowUp" ->
          if (currxind == 1){
              var newxind = currxind;
              var newyind = curryind;
              var square = selectElem(selectElem(grid, newxind), newyind);
              var newroom = square.room;
              var newxpos = square.tpos;
              var newypos = square.lpos;
              (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
            }
            else {
              var newxind = currxind - 1;
              var newyind = curryind;
              var square = selectElem(selectElem(grid, newxind), newyind);
              var newroom = square.room;
              var newxpos = square.tpos;
              var newypos = square.lpos;
            (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
            }
        case "ArrowLeft" -> 
          if (curryind == 1){
              var newxind = currxind;
              var newyind = curryind;
              var square = selectElem(selectElem(grid, newxind), newyind);
              var newroom = square.room;
              var newxpos = square.tpos;
              var newypos = square.lpos;
              (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
            }
            else {
              var newxind = currxind;
              var newyind = curryind - 1;
              var square = selectElem(selectElem(grid, newxind), newyind);
              var newroom = square.room;
              var newxpos = square.tpos;
              var newypos = square.lpos;
              (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
            }
        case "ArrowRight" ->
          if (curryind == columns-2){
              var newxind = currxind;
              var newyind = curryind;
              var square = selectElem(selectElem(grid, newxind), newyind);
              var newroom = square.room;
              var newxpos = square.tpos;
              var newypos = square.lpos;
              (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
            }
            else {
              var newxind = currxind;
              var newyind = curryind + 1;
              var square = selectElem(selectElem(grid, newxind), newyind);
              var newroom = square.room;
              var newxpos = square.tpos;
              var newypos = square.lpos;
              (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
            }
        case other ->
          var newxind = currxind;
          var newyind = curryind;
          var square = selectElem(selectElem(grid, newxind), newyind);
          var newroom = square.room;
          var newxpos = square.tpos;
          var newypos = square.lpos;
          (pid = pid, xind = newxind, yind = newyind, room = newroom, xpos = newxpos, ypos = newypos)
        }
}

fun getPid(id, pids){
  switch(pids){
    case p::ps ->
      if (second(p) == id){
        first(p)
      }else{
        getPid(id, ps)
      }
  }
}

fun updatePidRooms(id, pids, room){
    switch(pids){
    case [] -> 
      []
    case p::ps ->
      if(second(p) == id){
        (first(p), second(p), room) :: updatePidRooms(id, ps, room)
      }else{
        p :: updatePidRooms(id, ps, room)
      }  
  }
}

fun addToRoom(room, id){
  print("add to room");
  (name=room.name, members=id :: room.members)
}

fun removeFromRoom(members, id){
  switch(members) {
    case [] ->
      []
    case p::ps ->
      if (p <> id){
        p :: removeFromRoom(ps, id)
      }
      else{
        removeFromRoom(ps, id)
      }
  }
}



fun updateRoomPids(id, rooms, oldroom, newroom){
    switch(rooms){
    case [] -> 
      []
    case p::ps ->
      if (p.name == newroom){
        addToRoom(p, id) :: updateRoomPids(id, ps, oldroom, newroom)
      }
      else if (p.name == oldroom){
        (name=p.name, members=removeFromRoom(p.members, id)) :: updateRoomPids(id, ps, oldroom, newroom)
      }
      else {
        p :: updateRoomPids(id, ps, oldroom, newroom)
      }
  }

}

# Runs on the server, distributes PID list
fun connectionServer(grid, pids, rooms) server {
  receive {

    case CreateGrid() ->
      var newgrid = createGrid(50.0, 50.0, [0..rows], [0..columns]);
      print("finished grid");
      connectionServer(newgrid, pids, rooms)
    case Register(newPid, conferenceStyle) ->
      var id = intToString(length(pids));
      var newPos = getGridPos(grid, id, startxind, startyind, "Init");
      broadcastPid(newPid, id, pids, newPos.room, "None");
      var newpids = (newPid, id, newPos.room) :: pids;
      broadcastCharacterMovement(newpids, newPos);
      newPid ! ChangeState(conferenceStyle);
      # newPid ! SetMyId(id);
      connectionServer(grid, newpids, rooms)

    case SendOffer(pid, initPid, sdp) ->
      pid ! OpenConnection(initPid);
      pid ! Offer(initPid, sdp);
      connectionServer(grid, pids, rooms)

    case SendAnswer(initPid, pid, sdp) ->
      initPid ! Answer(pid, sdp);
      connectionServer(grid, pids, rooms)
    
    case SendIceCandidates(initPid, pid, candidates) ->
      pid ! NewIceCandidates(initPid, candidates);
      connectionServer(grid, pids, rooms)
    
    case CharacterMoved(id, currxind, curryind, currroom, code, newroom) ->
      var newPos = if (code == "ChangeRoom"){
        getNewRoomPos(rooms, grid, id, currxind, curryind, newroom)
      } else{
        getGridPos(grid, id, currxind, curryind, code)
      };
      var pid = getPid(id, pids);
      if (newPos.room <> currroom){
        broadcastPid(pid, id, pids, newPos.room, currroom);
        broadcastCharacterMovement(pids, newPos);
        var newpids = updatePidRooms(id, pids, newPos.room);
        # var newrooms = updateRoomPids(id, rooms, currroom, newPos.room);
        connectionServer(grid, newpids, rooms)
      }else{
        broadcastCharacterMovement(pids, newPos);
        connectionServer(grid, pids, rooms)
      }
  }
}


var serverPid = spawn { connectionServer([], [], [lounge,kitchen,ballroom,study,lobby]) };

fun awaitLocalSDPLoop(ourpid){
  if (WebRTC.isLocalSDP(ourpid)){
  }
  else{
    awaitLocalSDPLoop(ourpid)
  }
}

fun awaitRemoteSDPLoop(ourpid){
  if (WebRTC.isRemoteSDP(ourpid)){
  }
  else{
    awaitRemoteSDPLoop(ourpid)
  }
}

fun awaitVideoLoop(){
  if (WebRTC.isLocalVideo()){
  }
  else{
    awaitVideoLoop()
  }
}

fun getNewIceCandidates(mypid, serverPid, pid){
  switch (WebRTC.getIsNewIceCandidate(pid)){
    case "True" ->
      print("is new ice candidate true");
      var candidates = WebRTC.getNewIceCandidates(pid);
      serverPid ! SendIceCandidates(mypid, pid, candidates);
      getNewIceCandidates(mypid, serverPid, pid)
    case "False" ->
      getNewIceCandidates(mypid, serverPid, pid)
    case "End" ->
      ()
  }
  
}

fun clientLoop(handler) client {
  receive {
    case StartRegistration(conferenceStyle) ->
      var mypid = self();
      domReplaceChildren(
          <#>
          <video id="localVideo" width="320" height="240" autoplay="true">
          </video>
          </#>
          , getNodeById("localVideoContainer"));
      WebRTC.getLocalVideo();
      awaitVideoLoop();
      print("finished waiting");
      serverPid ! Register(mypid, conferenceStyle);
      clientLoop(handler)

    case SetMyId(id) ->
      dispatch(SetPid(id), handler);
      clientLoop(handler)

    case RequestPosition(pid) ->
      dispatch(SendPosition(), handler);
      clientLoop(handler)

    case OpenConnection(withPid) ->
      var mypid = self();
      print("setting up new connection");
      WebRTC.setupRTCConnection(withPid);
      clientLoop(handler)

    case StartCall(pid) ->
      var ourpid = self();
      WebRTC.createOfferSDP(pid);    
      awaitLocalSDPLoop(pid);
      var myoffer = WebRTC.getOfferSDP(pid);
      print(myoffer);
      serverPid ! SendOffer(pid, ourpid, myoffer);
      clientLoop(handler)
    
    case Offer(initPid, sdp) ->
      print("receiving offer");
      var mypid = self();
      WebRTC.receiveOfferSDP(initPid, sdp);
      awaitRemoteSDPLoop(initPid);
      var iceLoop = spawnClient{getNewIceCandidates(mypid, serverPid, initPid)};
      WebRTC.createAnswerSDP(initPid);
      awaitLocalSDPLoop(initPid);
      var myanswer = WebRTC.getOfferSDP(initPid);
      serverPid ! SendAnswer(initPid, mypid, myanswer);
      clientLoop(handler)

    case Answer(initPid, sdp) ->
      print("receiving answer");
      var mypid = self();
      WebRTC.receiveOfferSDP(initPid, sdp);
      awaitRemoteSDPLoop(initPid);
      var iceLoop = spawnClient{getNewIceCandidates(mypid, serverPid, initPid)};
      print("finished");
      print(sdp);
      clientLoop(handler)

    case NewIceCandidates(pid, candidates) ->
      WebRTC.addNewIceCandidates(pid, candidates);
      clientLoop(handler)
    
    case Move(pos) ->
      dispatch(IMoved(pos), handler);
      clientLoop(handler)
    
    case OtherMoved(pos) ->
      dispatch(OtherMoved(pos), handler);
      clientLoop(handler)
    
    case CloseConnection(pid) ->
      print("close connection");
      WebRTC.closeRTCConnection(pid);
      clientLoop(handler)

    case ChangeState(newState) ->
      print("state change");
      dispatch(StateChange(newState), handler);
      clientLoop(handler)

    case UpdateRooms(id, oldroom, newroom) ->
      dispatch(UpdateRoomPids(id, oldroom, newroom), handler);
      clientLoop(handler)


}
}

fun updateOthersPositions(currentArray, newarray, pos){
  switch(currentArray){
    case [] -> pos::newarray
    case p::ps ->
      if (p.pid == pos.pid){
        newarray ++ [pos] ++ ps
      }
      else{
        updateOthersPositions(ps,p::newarray, pos)
      }
      
  }
}

typename Model = (state: String, myPosition: (pid: String, xind: Int, yind: Int, room: String, xpos: Float, ypos: Float), othersPositions: [(pid: String, xind: Int, yind: Int, room: String, xpos: Float, ypos: Float)], rooms: [(name:String, members:[String])]);
typename Msg = [|SetPid: String | UpdateEvent: KeyboardEvent | IMoved: (pid: String, xind: Int, yind: Int, room: String, xpos: Float, ypos: Float) | OtherMoved: (pid: String, xind: Int, yind: Int, room: String, xpos: Float, ypos: Float) | SendPosition | StateChange: String| UpdateRoomPids: (String, String, String)| ChangeRoom: (String)|];

sig updt : (Msg, Model) ~> Model
fun updt(msg, model){
  switch(msg) {
    case SetPid(mypid) ->
      print("I am "^^mypid);
      (state= model.state, myPosition= (pid=mypid, xind= model.myPosition.xind, yind= model.myPosition.yind, room = model.myPosition.room, xpos=model.myPosition.xpos, ypos=model.myPosition.ypos), othersPositions= model.othersPositions, rooms=model.rooms)
    case UpdateEvent(evt) -> 
        
        var myid = model.myPosition.pid;
        var code = intToString(evt.code);
        if (model.state == "spatial" && (code == "ArrowDown" || code == "ArrowUp" || code == "ArrowLeft" || code == "ArrowRight" || code == "RoomChange")){
          serverPid ! CharacterMoved(myid, model.myPosition.xind, model.myPosition.yind, model.myPosition.room, code, "None");
          model
        }else{
          model
        }

    case SendPosition() ->
      serverPid ! CharacterMoved(model.myPosition.pid, model.myPosition.xind, model.myPosition.yind, model.myPosition.room, "Init", "None");
      model
    case IMoved(newPos) ->
      (state=model.state, myPosition = newPos, othersPositions = model.othersPositions, rooms = model.rooms)

    case OtherMoved(pos) ->
      var newPositions = updateOthersPositions(model.othersPositions, [], pos);
      (state=model.state, myPosition = model.myPosition, othersPositions = newPositions, rooms = model.rooms)

    case StateChange(newState) ->
      (state=newState, myPosition = model.myPosition, othersPositions = model.othersPositions, rooms = model.rooms)

    case UpdateRoomPids(id, oldroom, newroom) ->
      (state=model.state, myPosition = model.myPosition, othersPositions = model.othersPositions, rooms = updateRoomPids(id, model.rooms, oldroom, newroom))

    case ChangeRoom(newroom) ->
      var myid = model.myPosition.pid;
      serverPid ! CharacterMoved(myid, model.myPosition.xind, model.myPosition.yind, model.myPosition.room, "ChangeRoom", newroom);
      model
}
}

fun textPar((k, v)) {
  p(MvuAttrs.empty, textNode(k ^^ ": " ^^ v))
}

fun i2s(i) { intToString(i) }
fun b2s(b) { if(b) { "true" } else { "false"} }

fun getOtherHTML(positions, htmlList) {
  switch(positions){
    case [] -> htmlList
    case p::ps -> 
      var props = MvuHTML.concat(
      [
      textNode(p.pid)
      ]);
      getOtherHTML(ps, htmlList ++ [div(style("position:absolute;top:"^^ floatToString(p.xpos)^^"px; left:"^^ floatToString(p.ypos)^^ "px; width:50px; height: 50px; outline: 2px solid black;"), props )])
  }
}

fun getRoomPids(rooms, myroom){
  switch(rooms) {
    case [] -> []
    case p::ps ->
      input(MvuAttrs.concat([onClick(fun() { ChangeRoom(p.name) }),type("button"), value(p.name)]), textNode("hello")) :: getRoomPids(ps, myroom)
  }
}




sig view : (Model) ~> HTML(Msg)
fun view(model) {
  switch(model.state){
    case "spatial" ->
      var body = getNodeById("background");   
      domSetStyleAttrFromRef(body, "height", "1400px");
      domSetStyleAttrFromRef(body, "width", "1400px");
      domSetStyleAttrFromRef(body, "background-image", "url(https://art.pixilart.com/sr2a3bba315969e.png)");
      domSetStyleAttrFromRef(body, "background-position", "center");
      domSetStyleAttrFromRef(body, "background-size", "cover");
      domSetStyleAttrFromRef(body, "top", "0px");
      domSetStyleAttrFromRef(body, "left", "0px");
      domSetStyleAttrFromRef(body, "position", "absolute");
      var props = MvuHTML.concat(
      [
      textNode("ME")
      ]);
      MvuHTML.concat([div(style("position:absolute; background-image: url(pixilart-drawing.png);"), textNode("")),MvuHTML.concat(getOtherHTML(model.othersPositions, [])), div(style("position:absolute;top:"^^ floatToString(model.myPosition.xpos)^^"px; left:"^^ floatToString(model.myPosition.ypos)^^ "px; width:50px; height: 50px; outline: 2px solid black;"), props)])
    
    case "static" ->
      MvuHTML.concat(getRoomPids(model.rooms, model.myPosition.room))
    case other ->
      MvuHTML.concat([])
  }
    
}

sig subscriptions : (Model) -> Sub(Msg)
fun subscriptions(_) {
  onKeyDown(fun(evt) { UpdateEvent(evt) })
}

fun clientStart(){
  var handler = runHandle("placeholder", (state="options", myPosition=(pid="None", xind=startxind, yind=startyind, room="Lobby", xpos=50.0, ypos=50.0), othersPositions=[], rooms=[loungemembers,kitchenmembers,ballroommembers,studymembers,lobbymembers]), view,
      fun (msg, model) { (updt(msg, model), MvuCommands.empty) }, subscriptions,
      MvuCommands.empty);
  clientLoop(handler)
}

fun mainPage(serverPid){
  var clientPid = spawnClient{ clientStart() };
  page
    <html>
      <head>
        <title>Links - Subscriptions</title>
      </head>
      <body>
        <div id="background">
        <div id="placeholder">
        </div>
        <div id="localVideoContainer" position="absolute" bottom="0px" right="0px">
        <input type="button" value="Standard View" l:onclick="{clientPid ! StartRegistration("static")}"/>
        <input type="button" value="Spatial View" l:onclick="{clientPid ! StartRegistration("spatial")}"/>
        </div>
        <div id="remoteVideo">
        </div>
        </div>
      </body>
    </html>

}


fun main() {
  serverPid ! CreateGrid;
  print("started\n");
  addRoute("/", fun(_) {mainPage(serverPid)});
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  serveWebsockets();
  servePages()
}

main()
