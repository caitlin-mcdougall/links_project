open import Mvu;
open import MvuHTML;
open import MvuAttrs;
open import MvuEvents;
open import MvuSubscriptions;
import MvuCommands;


module WebRTC {
  alien javascript "/js/webRTC_functions.js" {
    setupRTCConnection : (wild) ~%~> ();
    createOfferSDP : (wild) ~%~> ();
    getOfferSDP : (wild) ~%~> (String);
    isLocalSDP : (wild) ~%~> (Bool);
    createAnswerSDP : (wild) ~%~> ();
    receiveOfferSDP : (wild, String) ~%~> ();
    isRemoteSDP : (wild) ~%~> (Bool);
    getLocalVideo : () ~%~> ();
    isLocalVideo : () ~%~> (Bool);
    getIsNewIceCandidate : (wild) ~%~> (Bool);
    getNewIceCandidates : (wild) ~%~> (String);
    addNewIceCandidates : (wild, String) ~%~> ();
  }
}

fun broadcastPid(pid, currentPids) server {
  switch (currentPids) {
    case [] -> ()
    case p::ps ->
      var proc = first(p);
      proc ! OpenConnection(pid);
      proc ! NewPidRegistered(pid);
      proc ! StartCall(pid);
      broadcastPid(pid, ps)
  }
}

fun broadcastCharacterMovement(pids, pos) server {
  switch(pids){
    case [] -> ()
    case p::ps ->
      if(second(p) == pos.pid){
        broadcastCharacterMovement(ps, pos)
      }else{
        var proc = first(p);
        proc ! OtherMoved(pos);
        broadcastCharacterMovement(ps, pos)
      }  
  }
}

# Runs on the server, distributes PID list
fun connectionServer(pids) server {
  receive {
    case Register(newPid) ->
      broadcastPid(newPid, pids);
      var id = intToString(length(pids));
      newPid ! SetMyId(id);
      var newpids = (newPid, id) :: pids;
      # newPid ! SetMyId(id);
      connectionServer(newpids)

    case SendOffer(pid, initPid, sdp) ->
      pid ! OpenConnection(initPid);
      pid ! Offer(initPid, sdp);
      connectionServer(pids)

    case SendAnswer(initPid, pid, sdp) ->
      initPid ! Answer(pid, sdp);
      connectionServer(pids)
    
    case SendIceCandidates(initPid, pid, candidates) ->
      pid ! NewIceCandidates(initPid, candidates);
      connectionServer(pids)
    
    case CharacterMoved(pos) ->
      broadcastCharacterMovement(pids, pos);
      connectionServer(pids)
  }
}

var serverPid = spawn { connectionServer([]) };

fun awaitLocalSDPLoop(ourpid){
  if (WebRTC.isLocalSDP(ourpid)){
  }
  else{
    awaitLocalSDPLoop(ourpid)
  }
}

fun awaitRemoteSDPLoop(ourpid){
  if (WebRTC.isRemoteSDP(ourpid)){
  }
  else{
    awaitRemoteSDPLoop(ourpid)
  }
}

fun awaitVideoLoop(){
  if (WebRTC.isLocalVideo()){
  }
  else{
    awaitVideoLoop()
  }
}

fun getNewIceCandidates(mypid, serverPid, pid){
  if (WebRTC.getIsNewIceCandidate(pid)){
    print("is new ice candidate true");
    var candidates = WebRTC.getNewIceCandidates(pid);
    serverPid ! SendIceCandidates(mypid, pid, candidates);
    getNewIceCandidates(mypid, serverPid, pid)
  }
  else{getNewIceCandidates(mypid, serverPid, pid)}
  
}

fun clientLoop(handler) client {
  receive {
    case StartRegistration() ->
      var mypid = self();
      domReplaceChildren(
          <#>
          <video id="localVideo" width="320" height="240" autoplay="true">
          </video>
          <div id="remoteVideo">
          </div>
          </#>
          , getNodeById("localVideoContainer"));
      WebRTC.getLocalVideo();
      awaitVideoLoop();
      print("finished waiting");
      serverPid ! Register(mypid);
      clientLoop(handler)

    case SetMyId(id) ->
      dispatch(SetPid(id), handler);
      clientLoop(handler)
      

    case NewPidRegistered(pid) ->
      domReplaceChildren(
          <#>
          New pid
          </#>, getNodeById("messageDisplay")
      );
      pid ! SendMessage("hello");
      clientLoop(handler)
    
    case SendMessage(msg) ->
      domReplaceChildren(<#>{stringToXml(msg)}</#>, getNodeById("messageDisplay"));
      clientLoop(handler)

    case OpenConnection(withPid) ->
      var mypid = self();
      print("setting up new connection");
      WebRTC.setupRTCConnection(withPid);
      clientLoop(handler)

    case StartCall(pid) ->
      var ourpid = self();
      WebRTC.createOfferSDP(pid);    
      awaitLocalSDPLoop(pid);
      var myoffer = WebRTC.getOfferSDP(pid);
      print(myoffer);
      serverPid ! SendOffer(pid, ourpid, myoffer);
      clientLoop(handler)
    
    case Offer(initPid, sdp) ->
      print("receiving offer");
      var mypid = self();
      WebRTC.receiveOfferSDP(initPid, sdp);
      awaitRemoteSDPLoop(initPid);
      var iceLoop = spawnClient{getNewIceCandidates(mypid, serverPid, initPid)};
      WebRTC.createAnswerSDP(initPid);
      awaitLocalSDPLoop(initPid);
      var myanswer = WebRTC.getOfferSDP(initPid);
      serverPid ! SendAnswer(initPid, mypid, myanswer);
      clientLoop(handler)

    case Answer(initPid, sdp) ->
      print("receiving answer");
      var mypid = self();
      WebRTC.receiveOfferSDP(initPid, sdp);
      awaitRemoteSDPLoop(initPid);
      var iceLoop = spawnClient{getNewIceCandidates(mypid, serverPid, initPid)};
      print("finished");
      print(sdp);
      clientLoop(handler)

    case NewIceCandidates(pid, candidates) ->
      WebRTC.addNewIceCandidates(pid, candidates);
      clientLoop(handler)
    
    case OtherMoved(pos) ->
      dispatch(OtherMoved(pos), handler);
      clientLoop(handler)
}
}

fun updateOthersPositions(currentArray, newarray, pos){
  switch(currentArray){
    case [] -> pos::newarray
    case p::ps ->
      if (p.pid == pos.pid){
        newarray ++ [pos] ++ ps
      }
      else{
        updateOthersPositions(ps,p::newarray, pos)
      }
      
  }
}

typename Model = (myPosition: (pid: String, xpos: Float, ypos: Float), othersPositions: [(pid: String, xpos: Float, ypos: Float)]);
typename Msg = [|SetPid: String | UpdateEvent: KeyboardEvent | OtherMoved: (pid: String, xpos: Float, ypos: Float) |];

sig updt : (Msg, Model) ~> Model
fun updt(msg, model){
  switch(msg) {
    case SetPid(mypid) ->
      print("I am "^^mypid);
      (myPosition= (pid=mypid, xpos=model.myPosition.xpos, ypos=model.myPosition.ypos), othersPositions= model.othersPositions)
    case UpdateEvent(evt) -> 
        var mypid = model.myPosition.pid;
        var code = intToString(evt.code);
        switch(code){
            case "ArrowDown" -> 
              var newPos =  (pid = model.myPosition.pid, xpos = model.myPosition.xpos +. 2.5,ypos =  model.myPosition.ypos);
              serverPid ! CharacterMoved(newPos);
              (myPosition = newPos, othersPositions = model.othersPositions)
            case "ArrowUp" ->
              var newPos = (pid = model.myPosition.pid, xpos = model.myPosition.xpos -. 2.5, ypos = model.myPosition.ypos);
              serverPid ! CharacterMoved(newPos);
              (myPosition = newPos, othersPositions = model.othersPositions)
            case "ArrowLeft" -> 
              var newPos = (pid = model.myPosition.pid, xpos = model.myPosition.xpos, ypos = model.myPosition.ypos -. 2.5);
              serverPid ! CharacterMoved(newPos);
              (myPosition = newPos, othersPositions = model.othersPositions)
            case "ArrowRight" ->
              var newPos = (pid = model.myPosition.pid, xpos = model.myPosition.xpos, ypos = model.myPosition.ypos +. 2.5);
              serverPid ! CharacterMoved(newPos);
              (myPosition = newPos, othersPositions = model.othersPositions)
            case other ->
              var newPos = (pid = model.myPosition.pid, xpos = model.myPosition.xpos, ypos = model.myPosition.ypos);
              serverPid ! CharacterMoved(newPos);
              (myPosition = newPos, othersPositions = model.othersPositions)
        }
    case OtherMoved(pos) ->
      var newPositions = updateOthersPositions(model.othersPositions, [], pos);
      (myPosition = model.myPosition, othersPositions = newPositions)
}
}

fun textPar((k, v)) {
  p(MvuAttrs.empty, textNode(k ^^ ": " ^^ v))
}

fun i2s(i) { intToString(i) }
fun b2s(b) { if(b) { "true" } else { "false"} }

fun getOtherHTML(positions, htmlList) {
  switch(positions){
    case [] -> htmlList
    case p::ps -> 
      var props = MvuHTML.concat(map(textPar,
      [
      ("x position", floatToString(p.xpos)),
      ("y position", floatToString(p.ypos))
      ]));
      getOtherHTML(ps, htmlList ++ [div(style("position:absolute;top:"^^ floatToString(p.xpos)^^"px; left:"^^ floatToString(p.ypos)^^ "px; border-style: dotted;"), props )])
  }
}


sig view : (Model) ~> HTML(Msg)
fun view(model) {
    var props = MvuHTML.concat(map(textPar,
    [
    ("x position", floatToString(model.myPosition.xpos)),
    ("y position", floatToString(model.myPosition.ypos))
    ]));
    MvuHTML.concat([MvuHTML.concat(getOtherHTML(model.othersPositions, [])), div(style("position:absolute;top:"^^ floatToString(model.myPosition.xpos)^^"px; left:"^^ floatToString(model.myPosition.ypos)^^ "px;"), props)])
    
    
}

sig subscriptions : (Model) -> Sub(Msg)
fun subscriptions(_) {
  onKeyDown(fun(evt) { UpdateEvent(evt) })
}

fun clientStart(){
  var handler = runHandle("placeholder", (myPosition=(pid="None", xpos=50.0, ypos=50.0), othersPositions=[]), view,
      fun (msg, model) { (updt(msg, model), MvuCommands.empty) }, subscriptions,
      MvuCommands.empty);
  clientLoop(handler)
}

fun mainPage(serverPid){
  var clientPid = spawnClient{ clientStart() };
  page
    <html>
      <head>
        <title>Links - Subscriptions</title>
      </head>
      <body>
        <div id="placeholder">
        </div>
        <div id="messageDisplay">
        </div>
        <div id="localVideoContainer">
        <input type="button" value="load" l:onclick="{clientPid ! StartRegistration()}"/>
        </div>
      </body>
    </html>

}


fun main() {

  addRoute("/", fun(_) {mainPage(serverPid)});
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  serveWebsockets();
  servePages()
}

main()
